%---------
% Preamble
%---------
\documentclass[fleqn,12pt]{wlpeerj}
\usepackage{fixltx2e} % LaTeX patches, \textsubscript
\usepackage{cmap} % fix search and cut-and-paste in Acrobat
\usepackage{ifthen}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\definecolor{orange}{cmyk}{0,0.4,0.8,0.2}
\definecolor{darkorange}{rgb}{.71,0.21,0.01}
\definecolor{darkblue}{rgb}{.01,0.21,0.71}
\definecolor{darkgreen}{rgb}{.1,.52,.09}
\hypersetup{pdftex,  % needed for pdflatex
    breaklinks=true,  % so long urls are correctly broken across lines
    colorlinks=true,
    urlcolor=blue,
    linkcolor=darkblue,
    citecolor=darkgreen,
}

\setcounter{secnumdepth}{0}

% hyperlinks:
\ifthenelse{\isundefined{\hypersetup}}{
    \usepackage[colorlinks=true,linkcolor=blue,urlcolor=blue]{hyperref}
    \urlstyle{same} % normal text font (alternatives: tt, rm, sf)
}{}

\usepackage{caption}
\usepackage{subcaption}
\usepackage{float}


%%%%%%%%%%%%%%

% Default fixed font does not support bold face
\DeclareFixedFont{\ttb}{T1}{txtt}{bx}{n}{12} % for bold
\DeclareFixedFont{\ttm}{T1}{txtt}{m}{n}{12}  % for normal

% Custom colors
\usepackage{color}
\definecolor{deepblue}{rgb}{0,0,0.5}
\definecolor{deepred}{rgb}{0.6,0,0}
\definecolor{deepgreen}{rgb}{0,0.5,0}

\usepackage{listings}

% Python style for highlighting
\newcommand\pythonstyle{\lstset{
        language=Python,
        basicstyle=\ttm,
        otherkeywords={self},             % Add keywords here
        keywordstyle=\ttb\color{deepblue},
        emph={MyClass,__init__},          % Custom highlighting
        emphstyle=\ttb\color{deepred},    % Custom highlighting style
        stringstyle=\color{deepgreen},
        frame=tb,                         % Any extra options here
        showstringspaces=false            % 
}}


% Python environment
\lstnewenvironment{python}[1][]
{
    \pythonstyle
    \lstset{#1}
}
{}

% Python for external files
\newcommand\pythonexternal[2][]{{
        \pythonstyle
\lstinputlisting[#1]{#2}}}

% Python for inline
\newcommand\pythoninline[1]{{\pythonstyle\lstinline!#1!}}


%%%%%%%%%%%%%%


\PassOptionsToPackage{pdftex}{graphicx}
\usepackage{graphicx}  % Simplify graphics handling for figures


%-------------------------
% Begin scikit-image paper
%-------------------------

\begin{document}

\title{scikit-image: Image processing in Python\footnote{Distributed under
Creative Commons CC-BY 4.0, DOI 10.7717/peerj.453}}

% Author list affiliations
\author[1,2]{Stéfan van der Walt}
\affil[1]{Corresponding author: \protect\href{mailto:stefan@sun.ac.za}{stefan@sun.ac.za}}
\affil[2]{Stellenbosch University,
Stellenbosch, South Africa}
\author[3]{Johannes L. Schönberger}
\affil[3]{Department of Computer Science,
    University of North Carolina at Chapel Hill,
Chapel Hill, NC 27599, USA}
\author[4]{Juan Nunez-Iglesias}
\affil[4]{Victorian Life Sciences Computation Initiative,
Carlton, VIC, 3010, Australia}
\author[5]{François Boulogne}
\affil[5]{Department of Mechanical and Aerospace Engineering,
    Princeton University,
Princeton, New Jersey 08544, USA}
\author[6]{Joshua D. Warner}
\affil[6]{Department of Biomedical Engineering,
    Mayo Clinic,
Rochester, Minnesota 55905, USA}
\author[7]{Neil Yager}
\affil[7]{AICBT Ltd,
Oxford, UK}
\author[8]{Emmanuelle Gouillart}
\affil[8]{Joint Unit CNRS / Saint-Gobain,
Cavaillon, France}
\author[9]{Tony Yu}
\affil[9]{Enthought Inc.,
Austin, TX, USA}
\author[10]{the scikit-image contributors}
\affil[10]{\url{https://github.com/scikit-image/scikit-image/graphs/contributors}}

% Key words to associate with the article
\keywords{image processing, reproducible research, education, visualization}

%---------
% Abstract
%---------

\begin{abstract}
    scikit-image is an image processing library that implements algorithms and utilities for use in research, education and industry applications. It is released under the liberal ``Modified BSD'' open source license, provides a well-documented API in the Python programming language, and is developed by an active, international team of collaborators. In this paper we highlight the advantages of open source to achieve the goals of the scikit-image library, and we showcase several real-world image processing applications that use scikit-image.
\end{abstract}

\flushbottom
\maketitle
\thispagestyle{empty}

%-----------------------------------------------------------------
% Sections of the paper are included in separate files with \input
%-----------------------------------------------------------------

%-------------
% Introduction
%-------------

\section*{Introduction}
\label{sec:introduction}

In our data-rich world, images represent a significant subset of all measurements made. Examples include DNA microarrays, microscopy slides, astronomical observations, satellite maps, robotic vision capture, synthetic aperture radar images, and higher-dimensional images such as 3-D magnetic resonance or computed tomography imaging. Exploring these rich data sources requires sophisticated software tools that should be easy to use, free of charge and restrictions, and able to address all the challenges posed by such a diverse field of analysis.

This paper describes scikit-image, a collection of image processing algorithms implemented in the Python programming language by an active community of volunteers and available under the liberal BSD Open Source license. The rising popularity of Python as a scientific programming language, together with the increasing availability of a large eco-system of complementary tools, make it an ideal environment in which to produce an image processing toolkit.

The project aims are:

\begin{enumerate}
    \item  % First item
        \textit{To provide high quality, well-documented and easy-to-use implementations of common image processing algorithms.}

        Such algorithms are essential building blocks in many areas of scientific research, algorithmic comparisons and data exploration. In the context of reproducible science, it is important to be able to inspect any source code used for algorithmic flaws or mistakes. Additionally, scientific research often requires custom modification of standard algorithms, further emphasizing the importance of open source.

    \item  % Second item
        \textit{To facilitate education in image processing.}

        The library allows students in image processing to learn algorithms in a hands-on fashion by adjusting parameters and modifying code. In addition, a \texttt{novice} module is provided, not only for teaching programming in the ``turtle graphics'' paradigm, but also to familiarize users with image concepts such as color and dimensionality. Furthermore, the project takes part in the yearly Google Summer of Code program \footnote{\url{https://developers.google.com/open-source/soc}, Accessed: 2014-03-30}, where students learn about image processing and software engineering through contributing to the project.

    \item  % Third item
        \textit{To address industry challenges.}

        High quality reference implementations of trusted algorithms provide industry with a reliable way of attacking problems, without having to expend significant energy in re-implementing algorithms already available in commercial packages.  Companies may use the library entirely free of charge, and have the option of contributing changes back, should they so wish.
\end{enumerate}


%----------------
% Getting Started
%----------------

\section*{Getting started}
\label{sec:getting-started}

One of the main goals of scikit-image is to make it easy for any user to get started quickly--especially users already familiar with Python's scientific tools. To that end, the basic image is just a standard NumPy array, which exposes pixel data directly to the user. A new user can simply the load an image from disk (or use one of scikit-image's sample images), process that image with one or more image filters, and quickly display the results:

% Bring in correctly syntax highlighted example
\begin{python}
from skimage import data, io, filter

image = data.coins()  # or any NumPy array!
edges = filter.sobel(image)
io.imshow(edges)
\end{python}

\begin{figure}
    \includegraphics[width=\columnwidth]{getting_started_new.png}

    \caption[Getting started figure]{\label{fig:gettingstarted}Illustration of several functions available in scikit-image: adaptive threshold, local maxima, edge detection and labels. The use of NumPy arrays as our data container also enables the use of NumPy's built-in \texttt{histogram} function.}
\end{figure}

The above demonstration loads \texttt{data.coins}, an example image shipped with scikit-image.  For a more complete example, we import NumPy for array manipulation and matplotlib for plotting \citep{numpy,matplotlib}.  At each step, we add the picture or the plot to a matplotlib figure shown in Figure~\ref{fig:gettingstarted}.

\begin{python}
import numpy as np
import matplotlib.pyplot as plt

# Load a small section of the image.
image = data.coins()[0:95, 70:370]

fig, axes = plt.subplots(ncols=2, nrows=3,
figsize=(8, 4))
ax0, ax1, ax2, ax3, ax4, ax5  = axes.flat
ax0.imshow(image, cmap=plt.cm.gray)
ax0.set_title('Original', fontsize=24)
ax0.axis('off')
\end{python}

Since the image is represented by a NumPy array, we can easily perform operations such as building an histogram of the intensity values.

\begin{python}
# Histogram.
values, bins = np.histogram(image,
bins=np.arange(256))

ax1.plot(bins[:-1], values, lw=2, c='k')
ax1.set_xlim(xmax=256)
ax1.set_yticks([0, 400])
ax1.set_aspect(.2)
ax1.set_title('Histogram', fontsize=24)
\end{python}

To divide the foreground and background, we threshold the image to produce a binary image.  Several threshold algorithms are available. Here, we employ \linebreak\texttt{filter.threshold\_adaptive} where the threshold value is the weighted mean for the local neighborhood of a pixel.

\begin{python}
# Apply threshold.
from skimage.filter import threshold_adaptive

bw = threshold_adaptive(image, 95, offset=-15)

ax2.imshow(bw, cmap=plt.cm.gray)
ax2.set_title('Adaptive threshold', fontsize=24)
ax2.axis('off')
\end{python}

We can easily detect interesting features, such as local maxima and edges. The function \texttt{feature.peak\_local\_max} can be used to return the coordinates of local maxima in an image.

\begin{python}
# Find maxima.
from skimage.feature import peak_local_max

coordinates = peak_local_max(image, min_distance=20)

ax3.imshow(image, cmap=plt.cm.gray)
ax3.autoscale(False)
ax3.plot(coordinates[:, 1],
coordinates[:, 0], c='r.')
ax3.set_title('Peak local maxima', fontsize=24)
ax3.axis('off')
\end{python}

Next, a Canny filter (\texttt{filter.canny}) \citep{Canny} detects the edge of each coin.

\begin{python}
# Detect edges.
from skimage import filter

edges = filter.canny(image, sigma=3,
low_threshold=10,
high_threshold=80)

ax4.imshow(edges, cmap=plt.cm.gray)
ax4.set_title('Edges', fontsize=24)
ax4.axis('off')
\end{python}

Then, we attribute to each coin a label (\texttt{morphology.label}) that can be used to extract a sub-picture. Finally, physical information such as the position, area, eccentricity, perimeter, and moments can be extracted using \texttt{measure.regionprops}.

\begin{python}
# Label image regions.
from skimage.measure import regionprops
import matplotlib.patches as mpatches
from skimage.morphology import label

label_image = label(edges)

ax5.imshow(image, cmap=plt.cm.gray)
ax5.set_title('Labeled items', fontsize=24)
ax5.axis('off')

for region in regionprops(label_image):
# Draw rectangle around segmented coins.
minr, minc, maxr, maxc = region.bbox
rect = mpatches.Rectangle((minc, minr),
maxc - minc,
maxr - minr,
fill=False,
edgecolor='red',
linewidth=2)
ax5.add_patch(rect)

plt.tight_layout()
plt.show()
\end{python}

scikit-image thus makes it possible to perform sophisticated image processing tasks with only a few function calls.


%-----------------
% Library Contents
%-----------------

\section*{Library overview}
\label{library-contents}

The scikit-image project started in August of 2009 and has received contributions from more than 100 individuals\footnote{\url{https://www.ohloh.net/p/scikit-image}}.  The package can be installed on all major platforms (e.g. BSD, GNU/Linux, OS X, Windows) from, amongst other sources, the Python Package Index (PyPI)\footnote{\url{http://pypi.python.org}}, Continuum Analytics Anaconda\footnote{\url{https://store.continuum.io/cshop/anaconda}}, Enthought Canopy\footnote{\url{https://www.enthought.com/products/canopy}}, Python(x,y)\footnote{\url{https://code.google.com/p/pythonxy}}, NeuroDebian \citep{neurodebian} and GNU/Linux distributions such as Ubuntu\footnote{\url{http://packages.ubuntu.com}}. In March 2014 alone, the package was downloaded more than 5000 times from PyPI\footnote{\url{http://pypi.python.org/pypi/scikit-image}, Accessed 2014-03-30}.

As of version 0.10, the package contains the following sub-modules:

\begin{itemize}

    \item color: Color space conversion.
    \item data: Test images and example data.
    \item draw: Drawing primitives (lines, text, etc.) that operate on NumPy arrays.
    \item exposure: Image intensity adjustment, e.g., histogram equalization, etc.
    \item feature: Feature detection and extraction, e.g., texture analysis, corners, etc.
    \item filter: Sharpening, edge finding, rank filters, thresholding, etc.
    \item graph: Graph-theoretic operations, e.g., shortest paths.
    \item io: Wraps various libraries for reading, saving, and displaying images and video, such as Pillow\footnote{\url{http://pillow.readthedocs.org/en/latest/}, Accessed 2015-05-30} and FreeImage\footnote{\url{http://freeimage.sourceforge.net/}, Accessed 2015-05-15}.
    \item measure: Measurement of image properties, e.g., similarity and contours.
    \item morphology: Morphological operations, e.g., opening or skeletonization.
    \item novice: Simplified interface for teaching purposes.
    \item restoration: Restoration algorithms, e.g., deconvolution algorithms, denoising, etc.
    \item segmentation: Partitioning an image into multiple regions.
    \item transform: Geometric and other transforms, e.g., rotation or the Radon transform.
    \item viewer: A simple graphical user interface for visualizing results and exploring parameters.

\end{itemize}

For further details on each module, we refer readers to the API documentation
online\footnote{\url{http://scikit-image.org/docs/dev/api/api.html}}.


%---------------------------
% Data format and pipelining
%---------------------------

\section*{Data format and pipelining}
\label{sec:data-format-and-pipelining}

scikit-image represents images as NumPy arrays \citep{numpy}, the de facto standard for storage of multi-dimensional data in scientific Python. Each array has a dimensionality, such as 2 for a 2-D grayscale image, 3 for a 2-D multi-channel image, or 4 for a 3-D multi-channel image; a shape, such as $(M, N, 3)$ for an RGB color image with $M$ vertical and $N$ horizontal pixels; and a numeric data type, such as \texttt{float} for continuous-valued pixels and \texttt{uint8} for 8-bit pixels. Our use of NumPy arrays as the fundamental data structure maximizes compatibility with the rest of the scientific Python ecosystem. Data can be passed as-is to other tools such as NumPy, SciPy, matplotlib, scikit-learn \citep{scikit-learn}, Mahotas \citep{Mahotas}, OpenCV, and more.

Images of differing data-types can complicate the construction of pipelines. scikit-image follows an \textquotedbl{}Anything In, Anything Out\textquotedbl{} approach, whereby all functions are expected to allow input of an arbitrary data-type but, for efficiency, also get to choose their own output format. Data-type ranges are clearly defined. Floating point images are expected to have values between 0 and 1 (unsigned images) or -1 and 1 (signed images), while 8-bit images are expected to have values in \{0, 1, 2, ..., 255\}. We provide utility functions, such as \texttt{img\_as\_float}, to easily convert between data-types.


%----------------------
% Development practices
%----------------------

\section*{Development practices}
\label{sec:development-practices}

The purpose of scikit-image is to provide a high-quality library of powerful, diverse image processing tools free of charge and restrictions. These principles are the foundation for the development practices in the scikit-image community.

The library is licensed under the \emph{Modified BSD license}, which allows unrestricted redistribution for any purpose as long as copyright notices and disclaimers of warranty are maintained \citep{BSD}. It is compatible with GPL licenses, so users of scikit-image can choose to make their code available under the GPL. However, unlike the GPL, it does not require users to open-source derivative work (BSD is not a so-called copyleft license). Thus, scikit-image can also be used in closed-source, commercial environments.

The development team of scikit-image is an open community that collaborates on the \emph{GitHub} platform for issue tracking, code review, and release management\footnote{\url{https://github.com/scikit-image}}. \emph{Google Groups} is used as a public discussion forum for user support, community development, and announcements\footnote{\url{https://groups.google.com/group/scikit-image}}.

scikit-image complies with the PEP8 coding style standard \citep{PEP8} and the NumPy documentation format \citep{NumpyDoc} in order to provide a consistent, familiar user experience across the library similar to other scientific Python packages. As mentioned earlier, the data representation used is \emph{n}-dimensional NumPy arrays, which ensures broad interoperability within the scientific Python ecosystem. The majority of the scikit-image API is intentionally designed as a functional interface which allows one to simply apply one function to the output of another. This modular approach also lowers the barrier of entry for new contributors, since one only needs to master a small part of the entire library in order to make an addition.

We ensure high code quality by a thorough review process using the pull
request interface on GitHub\footnote{\url{https://help.github.com/articles/using-pull-requests}, Accessed 2014-05-15.}.
This enables the core developers and other interested parties to comment on
specific lines of proposed code changes, and for the proponents of the
changes to update their submission accordingly. Once all the changes have
been approved, they can be merged automatically. This process applies not
just to outside contributions, but also to the core developers.

The source code is mainly written in Python, although certain performance critical sections are implemented in Cython, an optimising static compiler for Python \citep{Cython}. scikit-image aims to achieve full unit test coverage, which is above 87\% as of release 0.10 and continues to rise. A continuous integration system\footnote{\url{https://travis-ci.org}, \url{https://coveralls.io}, Accessed 2014-03-30} automatically checks each commit for unit test coverage and failures on both Python 2 and Python 3. Additionally, the code is analyzed by flake8 \citep{flake8} to ensure compliance with the PEP8 coding style standards \citep{PEP8}. Finally, the properties of each public function are documented thoroughly in an API reference guide, embedded as Python docstrings and accessible through the official project homepage or an interactive Python console. Short usage examples are typically included inside the docstrings, and new features are accompanied by longer, self-contained example scripts added to the narrative documentation and compiled to a gallery on the project website. We use Sphinx \citep{Sphinx} to automatically generate both library documentation and the website.

The development master branch is fully functional at all times and can be obtained from GitHub. The community releases major updates as stable versions approximately every six months. Major releases include new features, while minor releases typically contain only bug fixes. Going forward, users will be notified about API-breaking changes through deprecation warnings for two full major releases before the changes are applied.


% Large section broken into separate files for each sub-section
\section*{Usage examples}
\label{sec:usage-examples}

%-------------------------
% Usage Examples: Research
%-------------------------

\subsection*{Research}
\label{sub:research}

Often, a disproportionately large component of research involves dealing with various image data-types, color representations, and file format conversion. scikit-image offers robust tools for converting between image data-types \citep{DirectX,OpenGL,GraphicsGemsI} and to do file input/output (I/O) operations.  Our purpose is to allow investigators to focus their time on research, instead of expending effort on mundane low-level tasks.

The package includes a number of algorithms with broad applications across image processing research, from computer vision to medical image analysis. We refer the reader to the current API documentation for a full listing of current capabilities\footnote{\url{http://scikit-image.org/docs/dev}, Accessed 2014-03-30}. In this section we illustrate two real-world usage examples of scikit-image in scientific research.

First, we consider the analysis of a large stack of images, each representing drying droplets containing nanoparticles (see Figure~\ref{fig:cracks}). As the drying proceeds, cracks propagate from the edge of the drop to its center. The aim is to understand crack patterns by collecting statistical information about their positions, as well as their time and order of appearance. To improve the speed at which data is processed, each experiment, constituting an image stack, is automatically analysed without human intervention. The contact line is detected by a circular Hough transform (\texttt{transform.hough\_circle}) providing the drop radius and its center. Then, a smaller concentric circle is drawn (\texttt{draw.circle\_perimeter}) and used as a mask to extract intensity values from the image. Repeating the process on each image in the stack, collected pixels can be assembled to make a space-time diagram. As a result, a complex stack of images is reduced to a single image summarizing the underlying dynamic process.

\begin{figure}[bht]
    \includegraphics[width=\columnwidth]{fig_cracks_new.png}

    \caption{scikit-image is used to track the propagation of cracks (black lines) in a drying colloidal droplet. The sequence of pictures shows the temporal evolution of the system with the drop contact line, in green, detected by the Hough transform and the circle, in white, used to extract an annulus of pixel intensities.  The result shown illustrates the angular position of cracks and their time of appearance. \label{fig:cracks}}
\end{figure}

Next, in regenerative medicine research, scikit-image is used to monitor the regeneration of spinal cord cells in zebrafish embryos (Figure \ref{fig:profile}). This process has important implications for the treatment of spinal cord injuries in humans \citep{Bhatt04,Thuret06}.

To understand how spinal cords regenerate in these animals, injured cords are subjected to different treatments. Neuronal precursor cells (labeled green in Figure \ref{fig:profile}, left panel) are normally uniformly distributed across the spinal cord. At the wound site, they have been removed. We wish to monitor the arrival of new cells at the wound site over time. In Figure \ref{fig:profile}, we see an embryo two days after wounding, with precursor cells beginning to move back into the wound site (the site of minimum fluorescence). The \texttt{measure.profile\_line} function measures the fluorescence along the cord, directly proportional to the number of cells. We can thus monitor the recovery process and determine which treatments prevent or accelerate recovery.

\begin{figure*}[bht]

    \includegraphics[width=\columnwidth]{fig-lesion_new.png}

    \caption{The \texttt{measure.profile\_line} function being used to track recovery in spinal cord injuries. (a): an image of fluorescently-labeled nerve cells in an injured zebrafish embryo. (b): the automatically determined region of interest. The SciPy library was used to determine the region extent \citep{scipy,scipylib}, and functions from the scikit-image \texttt{draw} module were used to draw it. (c): the image intensity along the line of interest, averaged over the displayed width. \label{fig:profile}}
\end{figure*}

%--------------------------
% Usage Examples: Education
%--------------------------

\subsection*{Education}
\label{education}

scikit-image's simple, well-documented application programming interface (API) makes it ideal for educational use, either via self-taught exploration or formal training sessions.

The online gallery of examples not only provides an overview of the functionality available in the package but also introduces many of the algorithms commonly used in image processing. This visual index also helps beginners overcome a common entry barrier: locating the class (denoising, segmentation, etc.) and name of operation desired, without being proficient with image processing jargon.  For many functions, the documentation includes links to research papers or Wikipedia pages to further guide the user.

Demonstrating the broad utility of scikit-image in education, thirteen-year-old Rishab Gargeya of the Harker School won the Synopsys Silicon Valley Science and Technology Championship using scikit-image in his project, ``A software based approach for automated pathology diagnosis of diabetic retinopathy in the human retina'' \citep{sciencefair}.

We have delivered image processing tutorials using scikit-image at various annual scientific Python conferences, such as PyData 2012, SciPy India 2012, and EuroSciPy 2013. Course materials for some of these sessions are found in \cite{scipylecturenotes} and are licensed under the permissive CC-BY license \citep{cc-by}. These typically include an introduction to the package and provide intuitive, hands-on introductions to image processing concepts. The well documented application programming interface (API) along with tools that facilitate visualization contribute to the learning experience, and make it easy to investigate the effect of different algorithms and parameters. For example, when investigating denoising, it is easy to observe the difference between applying a median filter (\texttt{filter.rank.median}) and a Gaussian filter (\texttt{filter.gaussian\_filter}), demonstrating that a median filter preserves straight lines much better.

Finally, easy access to readable source code gives users an opportunity to learn how algorithms are implemented and gives further insight into some of the intricacies of a fast Python implementation, such as indexing tricks and look-up tables.

%-------------------------
% Usage Examples: Industry
%-------------------------

\subsection*{Industry}
\label{industry}

Due to the breadth and maturity of its code base, as well as the its commercial-friendly license, scikit-image is well suited for industrial applications.

BT Imaging (\url{btimaging.com}) designs and builds tools that use photoluminescence (PL) imaging for photovoltaic applications. PL imaging can characterize the quality of multicrystalline silicon wafers by illuminating defects that are not visible under standard viewing conditions. The left panel of Figure \ref{fig:PL} shows an optical image of a silicon wafer, and the center panel shows the same wafer using PL imaging. In the right panel, the wafer defects and impurities have been detected through automated image analysis. scikit-image plays a key role in the image processing pipeline. For example, a Hough transform (\texttt{transform.hough\_line}) finds the wafer edges in order to segment the wafer from the background. scikit-image is also used for feature extraction. Crystal defects (dislocations) are detected using a band-pass filter, which is implemented as a Difference of Gaussians (\texttt{filter.gaussian\_filter}).

The image processing results are input to machine learning algorithms, which assess intrinsic wafer quality. Solar cell manufacturers can use this information to reject poor quality wafers and thereby increase the fraction of solar cells that have high solar conversion efficiency.

\begin{figure*}[bht]

    \includegraphics[width=\columnwidth]{fig_pl_new.png}

    \caption{(a): An image of an as-cut silicon wafer before it has been processed into a solar cell. (b): A PL image of the same wafer. Wafer defects, which have a negative impact solar cell efficiency, are visible as dark regions. (c): Image processing results. Defects in the crystal growth (dislocations) are colored blue, while red indicates the presence of impurities. \label{fig:PL}}
\end{figure*}

scikit-image is also applied in a commercial setting for biometric security applications. AICBT Ltd uses multispectral imaging to detect when a person attempts to conceal their identity using a facial mask\footnote{\url{http://www.aicbt.com/disguise-detection}, Accessed 2014-03-30}. scikit-image performs file I/O (\texttt{io.imread}), histogram equalization (\texttt{exposure.equalize\_hist}), and aligns a visible wavelength image with a thermal image (\texttt{transform.AffineTransform}). The system determines the surface temperature of a subject's skin and detects situations where the face is being obscured.


%------------------------------------------
% Example: image registration and stitching
%------------------------------------------

\section*{Example: image registration and stitching}
\label{sec:example-image-registration-and-stitching}

This section gives a step-by-step outline of how to perform panorama stitching using the primitives found in scikit-image. The full source code is at \url{https://github.com/scikit-image/scikit-image-demos}.

\subsection{Data loading}
\label{sub:data_loading}

The ``ImageCollection'' class provides an easy way of representing multiple images on disk. For efficiency, images are not read until accessed.

\begin{python}
from skimage import io
ic = io.ImageCollection('data/*')
\end{python}

Figure~\ref{fig:pano}(a) shows the Petra dataset, which displays the same facade from two different angles. For this demonstration, we will estimate a projective transformation that relates the two images. Since the outer parts of these photographs do not comform well to such a model, we select only the central parts. To further speed up the demonstration, images are downscaled to 25\% of their original size.

\begin{python}
from skimage.color import rgb2gray
from skimage import transform

image0 = rgb2gray(ic[0][:, 500:500+1987, :])
image1 = rgb2gray(ic[1][:, 500:500+1987, :])

image0 = transform.rescale(image0, 0.25)
image1 = transform.rescale(image1, 0.25)
\end{python}

\subsection{Feature detection and matching}
\label{sub:feature_detection_and_matching}

``Oriented FAST and rotated BRIEF'' (ORB) features \citep{ORB} are detected in both images. Each feature yields a binary descriptor; those are used to find the putative matches shown in Figure~\ref{fig:pano}(b).

\begin{python}
from skimage.feature import ORB, match_descriptors

orb = ORB(n_keypoints=1000, fast_threshold=0.05)

orb.detect_and_extract(image0)
keypoints1 = orb.keypoints
descriptors1 = orb.descriptors

orb.detect_and_extract(image1)
keypoints2 = orb.keypoints
descriptors2 = orb.descriptors

matches12 = match_descriptors(descriptors1,
descriptors2,
cross_check=True)
\end{python}

\subsection{Transform estimation}
\label{sub:transform_estimation}

To filter the matches, we apply RANdom SAmple Consensus (RANSAC) \citep{ransac}, a common method for outlier rejection. This iterative process estimates transformation models based on randomly chosen subsets of matches, finally selecting the model which corresponds best with the majority of matches. The new matches are shown in Figure~\ref{fig:pano}(c).

\begin{python}
from skimage.measure import ransac

# Select keypoints from the source (image to be
# registered) and target (reference image).

src = keypoints2[matches12[:, 1]][:, ::-1]
dst = keypoints1[matches12[:, 0]][:, ::-1]

model_robust, inliers = \
ransac((src, dst), ProjectiveTransform,
min_samples=4, residual_threshold=2)
\end{python}

\subsection{Warping}
\label{sub:warping}

Next, we produce the panorama itself. The first step is to find the shape of the output image by considering the extents of all warped images.

\begin{python}
r, c = image1.shape[:2]

# Note that transformations take coordinates in
# (x, y) format, not (row, column), in order to be
# consistent with most literature.
corners = np.array([[0, 0],
    [0, r],
    [c, 0],
[c, r]])

# Warp the image corners to their new positions.
warped_corners = model_robust(corners)

# Find the extents of both the reference image and
# the warped target image.
all_corners = np.vstack((warped_corners, corners))

corner_min = np.min(all_corners, axis=0)
corner_max = np.max(all_corners, axis=0)

output_shape = (corner_max - corner_min)
output_shape = np.ceil(output_shape[::-1])
\end{python}

The images are now warped according to the estimated transformation model. Values outside the input images are set to -1 to distinguish the ``background''.

A shift is added to ensure that both images are visible in their entirety. Note that \texttt{warp} takes the \textit{inverse} mapping as input.

\begin{python}
from skimage.color import gray2rgb
from skimage.exposure import rescale_intensity
from skimage.transform import warp
from skimage.transform import SimilarityTransform

offset = SimilarityTransform(translation=-corner_min)

image0_ = warp(image0, offset.inverse,
output_shape=output_shape, cval=-1)

image1_ = warp(image1, (model_robust + offset).inverse,
output_shape=output_shape, cval=-1)
\end{python}

An alpha channel is added to the warped images before merging them into a single image:

\begin{python}
def add_alpha(image, background=-1):
"""Add an alpha layer to the image.

The alpha layer is set to 1 for foreground
and 0 for background.
"""
rgb = gray2rgb(image)
alpha = (image != background)
return np.dstack((rgb, alpha))

image0_alpha = add_alpha(image0_)
image1_alpha = add_alpha(image1_)

merged = (image0_alpha + image1_alpha)
alpha = merged[..., 3]

# The summed alpha layers give us an indication of
# how many images were combined to make up each
# pixel.  Divide by the number of images to get
# an average.
merged /= np.maximum(alpha, 1)[..., np.newaxis]
\end{python}

The merged image is shown in Figure~\ref{fig:pano}(d). Note that, while the columns are well aligned, the color intensities at the boundaries are not well matched.

%----------------------
% Panorama multi-figure
%----------------------

\begin{figure}
    \includegraphics[width=\columnwidth]{pano_new.png}
    \caption{An example application of scikit-image: image registration and warping to combine overlapping images. (a): Photographs taken in Petra, Jordan by François Malan. License: CC-BY. (b): Putative matches computed from ORB binary features. (c): Matches filtered using RANSAC. (d): The second input frame (\textit{middle}) is warped to align with the first input frame (\textit{left}), yielding the averaged image shown on the right. (e): The final panorama image, registered and warped using scikit-image, blended with Enblend.\label{fig:pano}}

\end{figure}


\subsection{Blending}
\label{sub:blending}

To blend images smoothly we make use of the open source package Enblend \citep{Enblend}, which in turn employs multi-resolution splines and Laplacian pyramids \citep{burt_adelson_0,burt_adelson_1}. The final panorama is shown in Figure~\ref{fig:pano}(e).

%-----------
% Discussion
%-----------

\section*{Discussion}
\label{sec:discussion}

\subsection*{Related work}

In this section, we describe other libraries with similar goals to ours.

Within the scientific Python ecosystem, \textbf{Mahotas} contains many similar
functions, and is furthermore also designed to work with NumPy arrays
\citep{Mahotas}. The major philosophical difference between Mahotas and
scikit-image is that Mahotas is almost exclusively written in templated C++,
while scikit-image is written in Python and Cython. We feel that our choice
lowers the barrier of entry for new contributors. However,
thanks to the interoperability between the two provided by the NumPy array
data format, users don't have to choose between them, and can simply use the
best components of each.

ImageJ and its batteries-included \textbf{Fiji} distribution are probably the most
popular open-source tools for image analysis \citep{imagej,Fiji}. Although 
Fiji's breadth of functionality is unparalleled, it is centered around 
interactive, GUI use. For many developers, then, scikit-image offers several
advantages. Although Fiji offers a
programmable macro mode that supports many scripting languages, many of the
macro functions activate GUI elements and cannot run in headless mode. This
is problematic for data analysis in high-performance computing
cluster environments or web backends, for example. Additionally, Fiji's
inclusive plugin policy results in an inconsistent API and variable
documentation quality. Using scikit-image to develop new functionality or
to build batch applications for distributed computing is often much simpler,
thanks to its consistent API and the wide distribution of the scientific
Python stack.

In many respects, the \textbf{image processing toolbox} of the Matlab environment is
quite similar to scikit-image. For example, its API is mostly functional and
applies to generic multidimensional numeric arrays. However, Matlab's
commercial licensing can be a significant nuisance to users. Additionally,
the licensing cost increases dramatically for parallel computing, with
per-worker pricing\footnote{\url{http://www.mathworks.com.au/products/distriben/description3.html}, Accessed 2014-05-09}.
Finally, the closed source nature of the toolbox prevents users from
learning from the code or modifying it for specific purposes, which is a
common necessity in scientific research. We refer readers back to the
Development Practices section for a summary of the practical and
philosophical advantages of our open-source licensing.

\textbf{OpenCV} is a BSD-licensed open-source library focused on computer vision, with
a separate module for image processing \citep{opencv}. It is
developed in C/C++ and the project's main aim is to provide implementations for
real-time applications. This results in fast implementations with a comparatively high
barrier of entry for code study and modification. The library provides
interfaces for several high-level programming languages, including Python
through the NumPy-array data-type for images. The Python interface is
essentially a one-to-one copy of the underlying C/C++ API, and thus image
processing pipelines have to follow an imperative programming style. In
contrast, scikit-image provides a Pythonic interface with the option
to follow an imperative or functional approach. Beyond that, OpenCV's image
processing module is traditionally limited to 2-dimensional imagery.

The choice of image processing package depends on several factors, including
speed, code quality and correctness, community support, ecosystem, feature
richness, and users' ability to contribute. Sometimes, advantages in one
factor come at the cost of another. For example, our approach of writing code
in a high-level language may affect performance, or our strict code review
guidelines may hamper the number of features we ultimately provide. We
motivate our design decisions for scikit-image in the Development Practices
section, and leave readers to decide which library is right for them.

\subsection*{Roadmap}

In many open source projects, decisions about future development are made
through ``rough consensus and working code'' \citep{rfc2418}.  In scikit-image
there are two ways to propose new ideas: through discussion on the mailing
list, or as pull requests.  The latter route has the advantage of a concrete
implementation to guide the conversation, and often mailing list discussions
also result in a request for a proof of concept implementation.  While
conversations are usually led by active developers, the entire community is
invited to participate.  Once general agreement is reached that the proposed
idea aligns with the current project goals and is feasible, work is divided
on a volunteer basis.  As such, the schedule for completion is often
flexible.

The following goals have been identified for the next release of scikit-image:

\begin{itemize}
    \item Obtain full test coverage.
    \item Overhaul the functions for image reading/writing.
    \item Improve the project infrastructure, e.g. create an interactive
        gallery of examples.
    \item Add support for graph-based operations.
    \item Significantly extend higher dimensional (multi-layer) support.
\end{itemize}

We also invite readers to submit their own feature requests to the mailing list
for further discussion.

%-----------
% Conclusion
%-----------

\section*{Conclusion}
\label{sec:conclusion}

scikit-image provides easy access to a powerful array of image processing functionality. Over the past few years, it has seen significant growth in both adoption and contribution\footnote{\url{https://www.ohloh.net/p/scikit-image}, Accessed 2014-05-15}, and the team is excited to collaborate with others to see it grow even further, and to establish it the de facto library for image processing in Python.


%-----------------
% Acknowledgements
%-----------------

\section*{Acknowledgements}
\label{sec:acknowledgements}

We thank Timo Friedrich and Jan Kaslin for providing the zebrafish lesion data.
We also acknowledge the efforts of the more than 100 contributors to the
scikit-image code base (listed as "the scikit-image contributors" in the
author list).


% Finally, create the bibliograpy
\bibliography{skimage}

\end{document}
